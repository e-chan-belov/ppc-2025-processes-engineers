# Проверка лексикографической упорядоченности двух строк

- **Студент**: Белов Егор Алексеевич, группа 3823Б1ПР2
- **Технология**: SEQ | MPI
- **Вариант**: 26

## 1. Введение
Существует потребность в хранении и обработке коллекций текстовых предложений, хранимых в строках. Для решения этой проблемы можно применить всё те же алгоритмы и структуры данных, что и для хранения чисел. Очевидно, что в таком случае для некоторых алгоритмов может потребоваться определение упорядоченности строк. 

Эту проблему можно решить через определение лексикографичесой упорядоченности двух строк.

Наша задачу решить эту проблему с использованием параллельного программирования.

## 2. Постановка задачи
Даны две строки с количеством слов n1 и n2, содержащие предложения.

Требуется определить лексикографическую упорядоченность двух строк, то есть: необходимо убедиться, стоят ли слова в предложениях в лексикографическом порядке и являются ли обе строки упорядоченными относительно друг друга.

Тип входных данных:
```cpp
using InType = std::tuple<std::string, std::string>;
```
Тип выходных данных:
```cpp
using OutType = bool;
```
Ограничения:
- Предложением считается перечеслением слов через пробелы.
- Предложение не содержит следующие знаки: ',', '.', '!', ';', '?' и прочее.

## 3. Базовый алгоритм (Sequential)
Каждая строка проверяется на лексикографическую упорядоченность с помощью следующего алгоритма:
```cpp
  for (size_t index = 0; i < sentence.size() - 1; i++) {
    if (sentence[index] > sentence[index + 1]) {
      return false;
    }
  }
  return true;
```
То есть происходит лексикографическая проверка всех соседних пар слов. Если есть неупорядоченная пара, то строка не лексикографически упорядоченна, если неупорядоченных пар нет, то строка лексикографически упорядоченна.

Если хотя бы одна строка не прошла проверку, то алгоритм говорит, что строки неупорядочены, иначе алгоритм проверяет упорядоченность между двумя строками: 
```cpp
return FirstSentence.LastWord() <= SecondSentence.FirstWord();
```
То есть если последнее слово первого предложения упорядоченно относительного первого слова второго предложения, то алгоритм говорит о лексикографической упорядоченности, иначе говорит обратное.

## 4. Схема распараллеливания
### Краткое описание
1. Разделим все процессы на две группы - каждой группе по предложению.
2. Разделим предложение внутри группы на равные кусочки из слов - каждому процессу из группы по кусочку.
3. Каждый процесс локально определяет лексикографическую упорядоченность слов внутри своего кусочка предложения с помощью **IsPartSorted()**.
4. Каждый процесс посылает результат проверки своего кусочка в глобальную переменную с помощью **Allreduce()**.
5. Если каждый процесс вернул истину после проверки своего кусочка, то идёт проверка на упорядоченность между предложениями.
6. Каждый процесс записывает ответ.
### Алгоритм проверки кусочка на лексикографическую упорядоченность
```cpp
bool IsPartSorted(const std::vector<std::string> &words, int begin, int end) {
  if (end <= begin) {
    return true;
  }
  for (size_t i = begin; i < static_cast<size_t>(end) - 1; i++) {
    if (words[i] > words[i + 1]) {
      return false;
    }
  }
  return true;
}
```
### Алгоритм распределения кусочков по процессам
```cpp
bool local_ans = false;
if (rank < mpi_size / 2) {
    int chunk = CeilDiv(n1, mpi_size / 2);
    int begin = rank * chunk;
    int end = std::min(begin + chunk + 1, n1);
    local_ans = IsPartSorted(first, begin, end);
} else {
    int chunk = CeilDiv(n2, (mpi_size - (mpi_size / 2)));
    int begin = (rank - (mpi_size / 2)) * chunk;
    int end = std::min(begin + chunk + 1, n2);
    local_ans = IsPartSorted(second, begin, end);
}
```
### Cхема параллельной работы алгоритма
1. Каждый процесс принимает входные данные и определяет общее количество процессов и свой ранг и записывает в переменные **mpi_size** и **rank** соответственно.
2. Каждый процесс вычисляет координаты и размер своего кусочка через переменные **chunk**, **begin**, **end** с помощью переменных **n1** или **n2**, **mpi_size**, **rank**.
3. Каждый процесс проверяет на лексикографическую упорядоченность свой кусочек в предложении и записывает результат проверки в переменную **local_ans**.
4. Каждый процесс вызывает **Allreduce()**, посылая свои **local_ans**. **Allreduce()** применяет операцию MPI_LAND и возвращает каждому процессу результат в виде переменной **ans**.
5. Каждый процесс проверяет лексикографическую упорядоченность между двумя предложениями и записывает ответ в **GetOutput()**.
## 5. Детали реализации
|          Файл          |                 Назначение                  |
|------------------------|---------------------------------------------|
| `common.hpp`           | Определение входных, выходных типов задачи и тип тестов |
| `ops_seq.hpp/.cpp`     |         Последовательная реализаци  |
| `ops_mpi.hpp/.cpp`     |                MPI-реализация         |
| `functional/main.cpp`  |             Функциональные тесты          |
| `performance/main.cpp` |       Тесты производительности       |
## 6. Экспериментальная среда
|  Компонент |               Значение                       |
|------------|----------------------------------------------|
|     CPU    |           Apple M1                 |
|     RAM    |                 8 GB                       |
|     ОС     | OS: Ubuntu 24.04 (DevContainer / macOs 26.1) |
| Компилятор | GCC 13.3.0 (g++), C++20, CMake, Release     |
|     MPI    |        mpirun (Open MPI) 4.1.6            |
## 7. Результаты и обсуждение
### 7.1 Корректность
Для функциональных тестов: 4 .txt файла, содержащие два предложения и флаг для лексикографической упорядоченности.

Тесты были подобраны для проверок всех уникальных случаев работы алгоритма. Все тесты прошли проверку на SEQ и MPI реализации.
### 7.2 Производительность
Для тестов производительности: генерируется для каждого предложения 7000 одинаковых слов, алгоритм проверяет каждое слово в предложении.
| Mode        | Count | Time, s  | Speedup | Efficiency |
|-------------|-------|----------|---------|------------|
| seq         | 1     | 0,003986 | 1.00    | N/A        |
| mpi         | 2     | 0,002478 | 1,61    | 80.4%      |
## 8. Заключение
В ходе выполнения работы удалось реализовать алгоритм проверки лексикографической упорядоченности двух строк, распараллелить его при помощи MPI и увидеть эффективность работы параллельного алгоритма.
## 9. Источники
1. Сысоев А. В. Курс лекций по параллельному программированию
2. Документация Open MPI     https://www.open-mpi.org/doc/
3. Microsoft Функции MPI     https://learn.microsoft.com/ru-ru/message-passing-interface/mpi-functions